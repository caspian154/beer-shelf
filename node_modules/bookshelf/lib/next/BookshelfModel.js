'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _events = require('../base/events');

var _events2 = _interopRequireDefault(_events);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _eagerLoader = require('./eagerLoader');

var _eagerLoader2 = _interopRequireDefault(_eagerLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _has = Object.prototype.hasOwnProperty;

var BookshelfModel = function (_Events) {
  (0, _inherits3.default)(BookshelfModel, _Events);

  function BookshelfModel(context) {
    (0, _classCallCheck3.default)(this, BookshelfModel);

    var _this = (0, _possibleConstructorReturn3.default)(this, (BookshelfModel.__proto__ || Object.getPrototypeOf(BookshelfModel)).call(this));

    if (!context || !context.knex) {
      throw new Error('Valid context is required in Bookshelf.Model constructor');
    }

    // The current bookshelf context, wrapper for a knex context.
    _this.__context = context;

    // The knex query builder associated with this model
    _this.__knex = context.knex.queryBuilder();

    // The attributes for the current model
    _this.__attributes = new EmptyObject();

    // Previous attributes for the current model
    _this.__previousAttributes = new EmptyObject();

    // Whether the model has been fetched yet
    _this.__hasFetched = false;

    // Whether the model is considered to be "new"
    _this.__isNew = true;

    // Stores all of the loaded relations for a model
    _this.__relations = new EmptyObject();

    // Empty options stored for the current query chain
    _this.__options = new EmptyObject();
    return _this;
  }

  /**
   * @method
   * @private
   * @returns String representation of the object.
   */


  (0, _createClass3.default)(BookshelfModel, [{
    key: 'toString',
    value: function toString() {
      return '[Object Model]';
    }
  }, {
    key: 'resetQuery',
    value: function resetQuery() {
      this.__knex = null;
      return this;
    }
  }, {
    key: 'get',
    value: function get(key) {
      return this.__attributes[key];
    }
  }, {
    key: 'set',
    value: function set(key, val) {
      if (key == null) {
        return this;
      }
      var attrs = void 0;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if ((typeof key === 'undefined' ? 'undefined' : (0, _typeof3.default)(key)) === 'object') {
        attrs = key;
      } else {
        (attrs = {})[key] = val;
      }

      // Extract attributes and options.
      var current = this.attributes;
      var prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) {
        this.id = attrs[this.idAttribute];
      }

      // For each `set` attribute, update or delete the current value.
      for (var attr in attrs) {
        val = attrs[attr];
        if (!_lodash2.default.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        current[attr] = val;
      }
      return this;
    }
  }, {
    key: 'query',
    value: function query() {
      return this.__knex;
    }

    /**
     * [withRelated description]
     * @param  {[type]} relations [description]
     * @return {[type]}           [description]
     */

  }, {
    key: 'withRelated',
    value: function withRelated(relations) {
      return _bluebird2.default.try(function () {});
    }

    // Async methods:

    /**
     * @method Model#byPk
     *   Fetches a model, using the primary key defined for the model.
     *   If the model contains a composite primary key (key for multiple columns),
     *   provide an array with the primary key as it is defined on the idAttribute, or a
     *
     * @param  {number|string|array|Object} pk  Primary key of the model
     *
     * @return {Promise<Model>}    [description]
     */

  }, {
    key: 'byPk',
    value: function byPk(pk) {
      return _bluebird2.default.try(function () {});
    }

    /**
     * @method Model#save
     * @description
     *
     * `save` is used to perform either an insert or update query using the
     * model's set {@link Model#attributes attributes}.
     *
     * If the model {@link Model#isNew isNew}, any {@link Model#defaults defaults}
     * will be set and an `insert` query will be performed. Otherwise it will
     * `update` the record with a corresponding ID. This behaviour can be overriden
     * with the `method` option.
     *
     *     new Post({name: 'New Article'}).save().then(function(model) {
     *       // ...
     *     });
     *
     * If you only wish to update with the params passed to the save, you may pass
     * a {patch: true} flag to the database:
     *
     *     // update authors set "bio" = 'Short user bio' where "id" = 1
     *     new Author({id: 1, first_name: 'User'})
     *       .save({bio: 'Short user bio'}, {patch: true})
     *       .then(function(model) {
     *         // ...
     *       });
     *
     * Several events fired on the model when saving: a {@link Model#creating
     * "creating"}, or {@link Model#updating "updating"} event if the model is
     * being inserted or updated, and a "saving" event in either case. To
     * prevent saving the model (with validation, etc.), throwing an error inside
     * one of these event listeners will stop saving the model and reject the
     * promise. A {@link Model#created "created"}, or {@link Model#"updated"}
     * event is fired after the model is saved, as well as a {@link Model#saved
     * "saved"} event either way. If you wish to modify the query when the {@link
     * Model#saving "saving"} event is fired, the knex query object should is
     * available in `options.query`.
     *
     *     // Save with no arguments
     *     model.set({id: 5, firstName: "John", lastName: "Smith"}).save().then(function() { //...
     *
     *     // Or add attributes during save
     *     model.set({id: 5}).save({firstName: "John", lastName: "Smith"}).then(function() { //...
     *
     *     // Or, if you prefer, for a single attribute
     *     model.set({id: 5}).save('name', 'John Smith').then(function() { //...
     *
     * @param {string=}      key                      Attribute name.
     * @param {string=}      val                      Attribute value.
     * @param {Object=}      attrs                    A hash of attributes.
     * @param {Object=}      options
     *
     * @param {bool} [options.defer=false]
     *   Determine whether the save should be deferred until the next `bookshelf.sync`
     * @param {string=} options.method
     *   Explicitly select a save method, either `"update"` or `"insert"`.
     * @param {string} [options.defaults=false]
     *   Assign {@link Model#defaults defaults} in an `update` operation.
     * @param {bool} [options.patch=false]
     *   Only save attributes supplied in arguments to `save`.
     * @param {bool} [options.require=true]
     *   Throw a {@link Model.NoRowsUpdatedError} if no records are affected by save.
     *
     * @fires Model#saving
     * @fires Model#creating
     * @fires Model#updating
     * @fires Model#created
     * @fires Model#updated
     * @fires Model#saved
     *
     * @throws {Model.NoRowsUpdatedError}
     *
     * @returns {Promise<Model>} A promise resolving to the saved and updated model.
     */

  }, {
    key: 'save',
    value: function save() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return _bluebird2.default.try(function () {});
    }

    /**
     * `destroy` performs a `delete` on the model, using the model's {@link
     * Model#idAttribute idAttribute} to constrain the query.
     *
     * A {@link Model#destroying "destroying"} event is triggered on the model before being
     * destroyed. To prevent destroying the model (with validation, etc.), throwing an error
     * inside one of these event listeners will stop destroying the model and
     * reject the promise.
     *
     * A {@link Model#destroyed "destroyed"} event is fired after the model's
     * removal is completed.
     *
     * @method Model#destroy
     *
     * @param {Object=}      options                  Hash of options.
     * @param {Transaction=} options.transacting      Optionally run the query in a transaction.
     * @param {bool} [options.require=true]
     *   Throw a {@link Model.NoRowsDeletedError} if no records are affected by destroy.
     *
     * @example
     *
     * new User({id: 1})
     *   .destroy()
     *   .then(function(model) {
     *     // ...
     *   });
     *
     * @fires Model#destroying
     * @fires Model#destroyed
     *
     * @throws {Model.NoRowsDeletedError}
     *
     * @returns {Promise<Model>} A promise resolving to the destroyed and thus "empty" model.
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return _bluebird2.default.try(function () {});
    }

    /**
     * Fetches a {@link Model model} from the database, using any {@link
     * Model#attributes attributes} currently set on the model to form a `select`
     * query.
     *
     * A {@link Model#event:fetching "fetching"} event will be fired just before the
     * record is fetched; a good place to hook into for validation. {@link
     * Model#event:fetched "fetched"} event will be fired when a record is
     * successfully retrieved.
     *
     * If you need to constrain the query
     * performed by fetch, you can call {@link Model#query query} before calling
     * {@link Model#fetch fetch}.
     *
     *     // select * from `books` where `ISBN-13` = '9780440180296'
     *     new Book({'ISBN-13': '9780440180296'})
     *       .fetch()
     *       .then(function(model) {
     *         // outputs 'Slaughterhouse Five'
     *         console.log(model.get('title'));
     *       });
     *
     * _If you'd like to only fetch specific columns, you may specify a `columns`
     * property in the `options` for the {@link Model#fetch fetch} call, or use
     * {@link Model#query query}, tapping into the {@link Knex} {@link
     * Knex#column column} method to specify which columns will be fetched._
     *
     * single property, or an array of properties can be specified as a value for
     * the `withRelated` property. You can also execute callbacks on relations
     * queries (eg. for sorting a relation). The results of these relation queries
     * will be loaded into a {@link Model#relations relations} property on the
     * model, may be retrieved with the {@link Model#related related} method, and
     * will be serialized as properties on a {@link Model#toJSON toJSON} call
     * unless `{shallow: true}` is passed.
     *
     *     let Book = Bookshelf.Model.createClass({
     *       tableName: 'books',
     *       relations: {
     *         editions: {
     *           type: 'hasMany',
     *           model: 'edition'
     *         },
     *         chapters: {
     *           type: 'hasMany',
     *           model: 'chapter'
     *         },
     *         genre: {
     *           type: 'belongsTo',
     *           model: 'genre'
     *         }
     *       }
     *     })
     *
     *     bookshelf.book.where({'ISBN-13': '9780440180296'}).fetch({
     *       withRelated: [
     *         'genre', 'editions',
     *         { chapters: function(query) { query.orderBy('chapter_number'); }}
     *       ]
     *     }).then(function(book) {
     *       console.log(book.genre.toJSON())
     *       console.log(book.editions.toJSON())
     *       console.log(book.toJSON())
     *     });
     *
     * @method Model#fetch
     *
     * @param {Object=}  options - Hash of options.
     * @param {boolean=} [options.require=false]
     *   Reject the returned response with a {@link Model.NotFoundError
     *   NotFoundError} if results are empty.
     * @param {string|string[]} [options.columns='*']
     *   Specify columns to be retrieved.
     * @param {Transaction} [options.transacting]
     *  Optionally run the query in a transaction.
     * @param {string|Object|mixed[]} [options.withRelated]
     *  Relations to be retrieved with `Model` instance. Either one or more
     *  relation names or objects mapping relation names to query callbacks.
     *
     * @fires Model#fetching
     * @fires Model#fetched
     *
     * @throws {Model.NotFoundError}
     *
     * @returns {Promise<Model|null>}
     *  A promise resolving to the fetched {@link Model model} or `null` if
     *  none exists.
     *
     */

  }, {
    key: 'fetch',
    value: function fetch() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return _bluebird2.default.try(function () {});
    }

    /**
     * @method Model#fetchOrFail
     *
     * @example <caption>ES6</caption>
     *
     *    try {
     *      const author = await bookshelf.author.where({email: 'email@example.com'}).fetchOrFail()
     *
     *    } catch (e) {
     *      if (e instanceof NotFoundError) {
     *        await bookshelf.author.forge()
     *      }
     *    }
     *
     * @example
     *
     *
     *
     * @param  {Object} options [description]
     * @return {[type]}         [description]
     */

  }, {
    key: 'fetchOrFail',
    value: function fetchOrFail() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.fetch((0, _extends3.default)({}, options, { require: true }));
    }

    /**
     * Fetch a single model,
     * @param  {Object} options [description]
     * @return {[type]}         [description]
     */

  }, {
    key: 'fetchOne',
    value: function fetchOne() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return _bluebird2.default.try(function () {});
    }
  }, {
    key: 'fetchMany',
    value: function fetchMany() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return _bluebird2.default.try(function () {});
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return _bluebird2.default.try(function () {});
    }

    /**
     * @method Model#load
     * @description
     * The load method takes an array of relations to eager load attributes onto a
     * {@link Model}, in a similar way that the `withRelated` property works on
     * {@link Model#fetch fetch}. Dot separated attributes may be used to specify deep
     * eager loading.
     *
     * @example
     * new Posts().fetch().then(function(collection) {
     *   collection.at(0)
     *   .load(['author', 'content', 'comments.tags'])
     *   .then(function(model) {
     *     JSON.stringify(model);
     *   });
     * });
     *
     * {
     *   title: 'post title',
     *   author: {...},
     *   content: {...},
     *   comments: [
     *     {tags: [...]}, {tags: [...]}
     *   ]
     * }
     *
     * @param {string|string[]} relations The relation, or relations, to be loaded.
     * @param {Object=}      options Hash of options.
     * @param {Transaction=} options.transacting
     *   Optionally run the query in a transaction.
     * @returns {Promise<Model>} A promise resolving to this {@link Model model}
     */

  }, {
    key: 'load',
    value: function load(relations) {
      if (relations.length === 1 && Array.isArray(relations[0])) {
        return this.load.apply(this, (0, _toConsumableArray3.default)(relations[0]));
      }
      var columns = this.format((0, _extends3.default)({}, this.attributes));
      var withRelated = _lodash2.default.isArray(relations) ? relations : [relations];

      return (0, _eagerLoader2.default)();
      return this._handleEager([columns], (0, _extends3.default)({}, options, { shallow: true, withRelated: withRelated })).return(this);

      for (var i = 0; i < relations.length; i++) {
        var relation = relations[i];
      }
    }

    // Query Methods:

  }, {
    key: 'where',
    value: function where() {
      var _knex;

      (_knex = this.__knex).where.apply(_knex, arguments);
      return this;
    }
  }, {
    key: 'count',
    value: function count() {
      return this.knex.asPartial().count().then();
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.__deprecate('clear');
    }
  }, {
    key: 'escape',
    value: function escape() {
      this.__deprecate('escape');
    }
  }, {
    key: 'clone',
    value: function clone() {}
  }, {
    key: 'fetchAll',
    value: function fetchAll() {}
  }, {
    key: 'fetchPage',
    value: function fetchPage() {}
  }, {
    key: 'has',
    value: function has(key) {
      return _has.call(this.__attributes, key);
    }
  }, {
    key: 'hasChanged',
    value: function hasChanged(key) {
      return _has.call(this.__attributes, key) !== _has.call(this.__previousAttributes, key) || this.__attributes[key] !== this.__previousAttributes[key];
    }
  }, {
    key: 'isNew',
    value: function isNew() {
      return this.__isNew;
    }
  }, {
    key: 'orderBy',
    value: function orderBy() {
      var _knex2;

      (_knex2 = this.__knex).orderBy.apply(_knex2, arguments);
      return this;
    }
  }, {
    key: 'parse',
    value: function parse() {}
  }, {
    key: 'previous',
    value: function previous(key) {
      return this.__previousAttributes[key];
    }
  }, {
    key: 'previousAttributes',
    value: function previousAttributes() {
      return (0, _extends3.default)({}, this.__previousAttributes);
    }
  }, {
    key: 'related',
    value: function related(relationName) {
      this.__relations;
    }
  }, {
    key: 'timestamp',
    value: function timestamp() {}

    /**
     * @method
     * @description
     *
     * Called automatically by {@link
     * https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior
     * `JSON.stringify`}. To customize serialization, override {@link
     * Model#serialize serialize}.
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this.serialize();
    }

    /**
     * @method
     * @description
     *
     * Return a copy of the model's {@link Model#attributes attributes} for JSON
     * stringification. If the {@link Model model} has any relations defined, this
     * will also call {@link Model#toJSON toJSON} on each of the related
     * objects, and include them on the object unless `{shallow: true}` is
     * passed as an option.
     *
     * `serialize` is called internally by {@link Model#toJSON toJSON}. Override
     * this function if you want to customize its output.
     *
     * @example
     * var artist = new bookshelf.Model({
     *   firstName: "Wassily",
     *   lastName: "Kandinsky"
     * });
     *
     * artist.set({birthday: "December 16, 1866"});
     *
     * console.log(JSON.stringify(artist));
     * // {firstName: "Wassily", lastName: "Kandinsky", birthday: "December 16, 1866"}
     *
     * @param {Object=} options
     * @param {bool}    [options.shallow=false]   Exclude relations.
     * @param {bool}    [options.omitPivot=false] Exclude pivot values.
     * @returns {Object} Serialized model as a plain object.
     */

  }, {
    key: 'serialize',
    value: function serialize() {
      return (0, _extends3.default)({}, this.__attributes);
    }
  }, {
    key: 'unset',
    value: function unset(key) {
      this.log.deprecate('unset');
      return this.set(key, undefined);
    }
  }, {
    key: '__deprecate',
    value: function __deprecate(methodName) {
      this.__knex.warn('Bookshelf: model.' + methodName + ' is deprecated');
    }
  }, {
    key: 'log',
    get: function get() {
      return this.__context.log;
    }
  }, {
    key: 'context',
    get: function get() {
      return this.__context;
    }
  }, {
    key: 'knex',
    get: function get() {
      return this.__knex || (this.__knex = this.__context.knex.table(this.tableName));
    }
  }, {
    key: 'attributes',
    get: function get() {
      return this.__attributes;
    },
    set: function set(obj) {
      this.__attributes = new EmptyObject();
      for (var key in obj) {
        this.__attributes[key] = obj[key];
      }
    }
  }]);
  return BookshelfModel;
}(_events2.default);

exports.default = BookshelfModel;


BookshelfModel.prototype.format = _lodash2.default.identity;

BookshelfModel.prototype.hasTimestamps = false;

BookshelfModel.prototype.idAttribute = 'id';

var staticProps = ['idAttribute', 'tableName', 'relations'];

/**
 * Create a new class for the Bookshelf model.
 * @param  {Object} classProps
 * @return {Model}
 */
BookshelfModel.createClass = function bookshelfExtend() {
  var classProps = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];


  var InheritingModel = this;

  if (arguments.length > 1) {
    throw new Error('Bookshelf.createClass only accepts a single object as a property');
  }

  var ExtendedBookshelfModel = function (_InheritingModel) {
    (0, _inherits3.default)(ExtendedBookshelfModel, _InheritingModel);

    function ExtendedBookshelfModel() {
      (0, _classCallCheck3.default)(this, ExtendedBookshelfModel);
      return (0, _possibleConstructorReturn3.default)(this, (ExtendedBookshelfModel.__proto__ || Object.getPrototypeOf(ExtendedBookshelfModel)).apply(this, arguments));
    }

    return ExtendedBookshelfModel;
  }(InheritingModel);

  for (var extendKey in classProps) {
    var value = classProps[extendKey];
    if (staticProps.indexOf(extendKey) === -1) {
      ExtendedBookshelfModel.prototype[extendKey] = value;
    } else {
      ExtendedBookshelfModel[extendKey] = value;
    }
  }

  return ExtendedBookshelfModel;
};

// Empty constructor fn for storing relations / attributes
function EmptyObject() {}
EmptyObject.prototype = Object.create(null);
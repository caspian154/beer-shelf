'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

exports.default = bookshelfNext;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _events = require('../base/events');

var _events2 = _interopRequireDefault(_events);

var _modelFactory = require('./modelFactory');

var _modelFactory2 = _interopRequireDefault(_modelFactory);

var _configureRelations = require('./configureRelations');

var _configureRelations2 = _interopRequireDefault(_configureRelations);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function bookshelfNext(rootKnex) {
  var config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


  if (!rootKnex.isRootContext()) {
    throw new Error('Bookshelf must be initialized with the root knex object');
  }

  // All of the model classes used in the ORM are stored here.
  var modelClasses = Object.create(null);

  // A "BookshelfContext" keeps track of all models across a single
  // boundary. The most common case of a Bookshelf context will be to
  // group all objects fetched & persisted across a single
  // request/response cycle.

  var BookshelfContext = function (_Events) {
    (0, _inherits3.default)(BookshelfContext, _Events);

    function BookshelfContext(knex, parentContext) {
      (0, _classCallCheck3.default)(this, BookshelfContext);

      // The current knex context
      var _this = (0, _possibleConstructorReturn3.default)(this, (BookshelfContext.__proto__ || Object.getPrototypeOf(BookshelfContext)).call(this));

      _this.__knex = knex;

      // If a "__parentContext" exists, it means all objects fetched
      // for the current model should be persisted across the current
      // context, keeping an identity map based on primary and secondary keys.
      _this.__parentContext = parentContext;

      // All objects fetched for a particular context are stored here
      _this.__objects = {};

      // All touched but unsync'ed models are referenced here.
      _this.__touched = {};
      return _this;
    }

    /**
     * @method bookshelf#isRootContext
     *
     * @description
     * Passthrough to knex#isRootContext, determines whether the current
     * context is the root context for a model.
     *
     * @return {Boolean}
     */


    (0, _createClass3.default)(BookshelfContext, [{
      key: 'isRootContext',
      value: function isRootContext() {
        return Boolean(this.__parentContext);
      }
    }, {
      key: 'load',


      /**
       * Load one or more relations on the provided
       * model or collection.
       *
       * @param  {Object} modelOrCollection [description]
       * @param  {Array} relations          [description]
       * @return {Promise<Model|Array<Model>>}
       */
      value: function load(modelOrCollection, relations) {
        return _bluebird2.default.try(function () {});
      }

      /**
       * bookshelf#transaction
       * @memberOf bookshelf
       * @description
       *
       * Creates a new knex transaction and a new Bookshelf context
       * where all created models use the same knex instance.
       *
       * @param  {[type]} config [description]
       * @return {[type]}        [description]
       */

    }, {
      key: 'transaction',
      value: function transaction(config) {
        var trx = this.knex.transaction();
        return new BookshelfContext(trx, this);
      }

      /**
       * [context description]
       * @param  {[type]} config [description]
       * @return {[type]}        [description]
       */

    }, {
      key: 'context',
      value: function context(config) {
        var ctx = this.knex.context();
        return new BookshelfContext(ctx, this);
      }

      /**
       * @method bookshelf#model
       * @memberOf bookshelf
       * @description
       *
       * Instantiates a new model for the current bookshelf context.
       * This ensures any queries involving the model are executed on the same
       * transaction / context.
       *
       * @param  {string} modelName
       * @return {Model}  Instantiated Model class
       */

    }, {
      key: 'model',
      value: function model(modelName) {
        var ModelClass = modelClasses[modelName];
        return new ModelClass(this);
      }

      /**
       * @method bookshelf#refresh
       *
       * Refreshes a model or a collection of models,
       * assuming the collection of models have all been fetched using
       * the same query.
       *
       * @param  {[type]} modelOrCollection [description]
       * @return {[type]}                   [description]
       */

    }, {
      key: 'refresh',
      value: function refresh(modelOrCollection) {
        return _bluebird2.default.try(function () {});
      }

      /**
       * Ends the current bookshelf context.
       * @return {[type]} [description]
       */

    }, {
      key: 'end',
      value: function end() {
        if (this.isRootContext()) {
          throw new Error('Cannot call end on a root bookshelf instance');
        }
      }
    }, {
      key: 'isTransaction',
      value: function isTransaction() {
        var _knex;

        return (_knex = this.__knex).isTransaction.apply(_knex, arguments);
      }
    }, {
      key: 'isInTransaction',
      value: function isInTransaction() {
        var _knex2;

        return (_knex2 = this.__knex).isInTransaction.apply(_knex2, arguments);
      }

      /**
       * @method bookshelf#commit
       *
       * @description
       * Commit the current transaction, only valid within a
       * transaction bookshelf context.
       *
       * @return {Promise<void>}
       */

    }, {
      key: 'commit',
      value: function commit() {
        var _knex3;

        return (_knex3 = this.__knex).commit.apply(_knex3, arguments);
      }

      /**
       * @method bookshelf#commit
       *
       * @description
       *
       * Rollback the current transaction, only valid within a
       * transaction bookshelf context.
       *
       * @return {Promise<void>}
       */

    }, {
      key: 'rollback',
      value: function rollback() {
        var _knex4;

        return (_knex4 = this.__knex).rollback.apply(_knex4, arguments);
      }

      /**
       * @method bookshelf#syncChanges
       *
       *
       * @return {[type]} [description]
       */

    }, {
      key: 'syncChanges',
      value: async function syncChanges() {
        if (this.isRootContext()) {
          throw new Error('Unit-of-work sync is only possible inside a context / transaction');
        }
      }
    }, {
      key: 'VERSION',
      get: function get() {
        return '1.0.0-pre';
      }
    }, {
      key: 'knex',
      get: function get() {
        return this.__knex;
      }
    }, {
      key: 'log',
      get: function get() {
        return this.__knex.log;
      }
    }]);
    return BookshelfContext;
  }(_events2.default);

  if (!config.models) {
    throw new Error('Missing an Array of "models" in the bookshelf config ' + 'read more about the new Bookshelf structure here: ');
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var modelName = _step.value;


      var ModelClass = config.models[modelName];

      if (typeof ModelClass !== 'function') {
        ModelClass = (0, _modelFactory2.default)(modelName, ModelClass);
      }

      modelClasses[modelName] = ModelClass;

      if (BookshelfContext.prototype.hasOwnProperty(modelName)) {
        rootKnex.log.warn('Cannot assign ' + modelName + ' as a getter on the bookshelf instance ' + 'because it collides with an existing prototype property. ' + ('Call bookshelf.model("' + modelName + '") to retrieve an instance of this model'));
      } else {
        Object.defineProperty(BookshelfContext.prototype, modelName, {
          get: function get() {
            return this.model(modelName);
          }
        });
      }
    };

    for (var _iterator = config.models[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }

    // Statically configure the relations for the various models,
    // checking for any errors, etc.
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  (0, _configureRelations2.default)(modelClasses);

  return new BookshelfContext(rootKnex);
}
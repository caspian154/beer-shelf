'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

exports.default = configureRelations;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Mutates the model definitions, wiring up any relations beween the models
 * and creating getters which
 *
 * @param  {[type]} modelClasses [description]
 * @return {[type]}              [description]
 */
function configureRelations(modelClasses) {
  var keys = Object.keys(modelClasses);

  var errors = [];
  var throughModels = [];

  for (var modelName in modelClasses) {
    var ModelClass = modelClasses[modelName];
    var relations = ModelClass.relations || {};

    for (var relationName in relations) {
      var relation = relations[relationName];
      var type = relation.type;
      var model = relation.model;
      var through = relation.through;


      if (!modelClasses[model]) {
        errors.push('Missing model ' + model + ' in relation ' + modelName + '.' + relationName + ' definition, expected one of: ' + keys.join(', '));
        continue;
      }

      // Through relations are performed using joins via other models.
      // Ensure those models process any other relations before we check on the
      if (through) {
        throughModels.push([modelName, relationName, relation]);
        continue;
      }

      if (!relationTypes.hasOwnProperty(type)) {
        errors.push('Invalid relation type ' + type + ' in ' + modelName + '.' + relationName + ', expected one of ' + validRelationTypes);
        continue;
      }

      relationTypes[type](modelClasses, ModelClass, relation);
    }
  }

  if (errors.length > 0) {
    throw new Error(errors.length + ' errors found in generating Bookshelf.Relations: \n', errors.join('\n'));
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = throughModels[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = (0, _slicedToArray3.default)(_step.value, 3);

      var _modelName = _step$value[0];
      var _relationName = _step$value[1];
      var _relation = _step$value[2];
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

var relationTypes = {
  hasOne: function hasOne(modelClasses, ModelClass, relation) {},
  hasOneThrough: function hasOneThrough(modelClasses, ModelClass, relation) {},
  morphMany: function morphMany(modelClasses, ModelClass, relation) {},
  morphManyThrough: function morphManyThrough(modelClasses, ModelClass, relation) {},
  morphOne: function morphOne(modelClasses, ModelClass, relation) {},
  morphOneThrough: function morphOneThrough(modelClasses, ModelClass, relation) {},
  morphTo: function morphTo(modelClasses, ModelClass, relation) {},
  morphToThrough: function morphToThrough(modelClasses, ModelClass, relation) {},
  belongsTo: function belongsTo(modelClasses, ModelClass, relation) {},
  belongsToThrough: function belongsToThrough(modelClasses, ModelClass, relation) {},
  belongsToManyThrough: function belongsToManyThrough(modelClasses, ModelClass, relation) {}
};

var validRelationTypes = Object.keys(relationTypes).join(', ');